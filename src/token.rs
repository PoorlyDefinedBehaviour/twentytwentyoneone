use crate::source_code::SourceSpan;

#[derive(Debug, PartialEq)]
pub enum Token {
  LeftBrace(SourceSpan),
  RightBrace(SourceSpan),
  LeftBracket(SourceSpan),
  RightBracket(SourceSpan),
  Comma(SourceSpan),
  Plus(SourceSpan),
  Minus(SourceSpan),
  Star(SourceSpan),
  Slash(SourceSpan),
  StarStar(SourceSpan),
  Percent(SourceSpan),
  PercentPercent(SourceSpan),
  Equal(SourceSpan),
  NotEqual(SourceSpan),
  LessThan(SourceSpan),
  GreaterThan(SourceSpan),
  LessThanOrEqual(SourceSpan),
  GreaterThanOrEqual(SourceSpan),
  Ampersand(SourceSpan),
  Pipe(SourceSpan),
  Bang(SourceSpan),
  LeftParen(SourceSpan),
  RightParen(SourceSpan),
  Program(SourceSpan),
  Identifier(String, SourceSpan),
  Define(SourceSpan),
  Not(SourceSpan),
  Variable(SourceSpan),
  Is(SourceSpan),
  Natural(SourceSpan),
  Real(SourceSpan),
  Char(SourceSpan),
  Boolean(SourceSpan),
  Execute(SourceSpan),
  Set(SourceSpan),
  Get(SourceSpan),
  To(SourceSpan),
  Put(SourceSpan),
  Loop(SourceSpan),
  While(SourceSpan),
  Do(SourceSpan),
  True(SourceSpan),
  False(SourceSpan),
  Eof,
}

pub fn token_from_identifier_or_keyword(lexeme: String, source_span: SourceSpan) -> Token {
  match lexeme.to_lowercase().as_str() {
    "program" => Token::Program(source_span),
    "define" => Token::Define(source_span),
    "not" => Token::Not(source_span),
    "variable" => Token::Variable(source_span),
    "is" => Token::Is(source_span),
    "natural" => Token::Natural(source_span),
    "real" => Token::Real(source_span),
    "char" => Token::Char(source_span),
    "boolean" => Token::Boolean(source_span),
    "execute" => Token::Execute(source_span),
    "set" => Token::Set(source_span),
    "get" => Token::Get(source_span),
    "to" => Token::To(source_span),
    "put" => Token::Put(source_span),
    "loop" => Token::Loop(source_span),
    "while" => Token::While(source_span),
    "do" => Token::Do(source_span),
    "true" => Token::True(source_span),
    "false" => Token::False(source_span),
    _ => Token::Identifier(lexeme, source_span),
  }
}
